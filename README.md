# Mini-Research-1
Devised a set of problems that specifically measure the Generative Aspect of AI in terms of Python coding. The generative capacity of AI, in the context of coding, can be tested by examining its proficiency in:

I.Code Imagination: Crafting new solutions or approaches.
Produce a function or code snippet that...

Represents a mathematical constant without directly using its value.
Recreates the behavior of Python's enumerate function without using it.
Generates the list of leap years from 2000 to 2100 without loops.
Computes the sum of ASCII values of a string.
Implements a basic Caesar cipher.
Validates an email address without regex.
Creates a list of the first N even numbers without loops.
Filters vowels from a given string.
Finds a character's immediate predecessor in a string.
Converts a list of words into a sentence.
Simulates a basic stopwatch.
Flips the key-value pairs of a dictionary.
Replicates the behavior of Python’s zip function.
Generates a random 6-character alphanumeric string.
Implements a basic queue using lists.
Computes the LCM of two numbers without using any libraries.
Checks if a given number is a palindrome.
Creates a basic string compressor (e.g., 'aaabbbb' to 'a3b4').
Generates a list of dates of the upcoming 10 Sundays.
Finds the index of the nth occurrence of a substring in a string.

II.Code Transformation: Altering code structure or intent.

Given a piece of code, modify it to...

Convert an iterative factorial function to a recursive one.
Change a function that checks for odd numbers to check for even numbers.
Alter a function that performs addition to perform subtraction.
Modify a bubble sort function to perform in descending order.
Change a function that reads a file to also write to it.
Convert a class-based stack to a class-based queue.
Alter a linear search function to become a binary search.
Modify a function that prints elements to return them as a list.
Transform a palindrome checker to check for anagrams.
Modify a string reverser to reverse words instead of characters.
Transform a function that fetches online data synchronously to do it asynchronously.
Alter a function returning the highest value in a list to return the lowest.
Change a Celsius to Fahrenheit converter to a Fahrenheit to Celsius converter.
Modify a 2D point class to a 3D point class.
Transform a breadth-first search algorithm to a depth-first search.
Alter a function that counts vowels to count consonants.
Modify a function that calculates area of a circle to compute perimeter.
Convert a while-loop based solution to a for-loop based solution.
Change a function that retrieves the first element of a list to retrieve the last.
Modify a recursive tree traversal to be iterative.

III.Pattern Recognition: Predicting or filling in code based on patterns.

A sequence of numbers representing factorial growth.
An unfinished function to compute Fibonacci sequence.
A list comprehension that's missing its condition.
The expected output for an encrypted message.
An incomplete class representing a basic calculator.
A pattern of strings following alphabetical order.
The output of a nested loop iterating over two lists.
An incomplete regex pattern to match URLs.
A sequence of dates skipping weekends.
The output for a partially completed arithmetic sequence.
An unfinished decorator function.
A series of number transformations (like squares or cubes).
The next function in a series of transformations (e.g., after len, sum, what’s next?).
An unfinished recursive function to compute sum of digits.
The pattern in a list of string manipulations.
An incomplete lambda function.
The pattern of numbers representing prime numbers.
A missing piece in a GUI event handling code.
An unfinished error-handling block.
The next in a series of string slicing patterns.

IV.Innovative Problem Solving: Solving problems using unconventional methods.
Devise a solution for...

Computing the factorial of a number using string manipulations.
Checking if two words are anagrams without sorting or counting characters.
Finding the longest word in a sentence without splitting the string.
Calculating the sum of digits without converting the number to a string.
Implementing a basic map function without loops.
Detecting a cycle in a list without additional memory (Floyd's Cycle-Finding).
Counting the occurrences of a word in a text without the count method.
Checking if a list is a palindrome without reversing the list.
Simulating dice throws without random numbers.
Extracting all numbers from a string without regex.
Determining if a string is uppercase without string methods.
Simulating a stack without lists or arrays.
Calculating the Nth Fibonacci number without loops or recursion (Binet's formula).
Checking if a number is even without arithmetic operations.
Sorting a list of numbers without using any sorting algorithm.
Reversing a string without slicing or built-in methods.
Checking if two strings have identical characters without data structures.
Implementing a shuffle of a list without random module.
Determining if two lists have a common element without nested loops.
Creating a mirror reflection of a string pyramid.

V.Function Generation: Generating a function from a description.

Given a description, generate a function that...

Returns the middle element of a list.
Calculates the average of a list of numbers.
Repeats a given string N times.
Counts the occurrences of each word in a string.
Merges two sorted lists into one sorted list.
Finds the difference between the largest and smallest numbers in a list.
Removes all vowels from a string.
Checks if all elements in a list are unique.
Determines if a string starts and ends with the same character.
Finds the common elements between two lists.
Generates a list of numbers from 1 to N, where numbers divisible by 3 are replaced by 'Fizz' and those by 5 by 'Buzz'.
Capitalizes the first letter of every word in a string.
Returns a list of all prime numbers up to N.
Determines if a string is a rotation of another.
Converts a flat list of numbers into a 2D matrix.
Transposes a 2D matrix.
Computes the power of a number without using the power operator or loops.
Flattens a nested list.
Finds the second highest value in a list.

In this demonstration:

There are two mock AI functions (AI_X and AI_Y).
We call evaluate for each AI function to get their scores on the problems.
We then call analyze to compare their performances.

Now, when we have multiple AIs generate solutions for each problem, we can use the evaluate function to get their scores and then the analyze function to compare their performances.
